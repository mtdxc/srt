```
MOPS                                                     M.P. Sharabayko
Internet-Draft                                           M.A. Sharabayko
Intended status: Standards Track           Haivision Network Video, GmbH
Expires: 13 March 2021                                           J. Dube
                                                               Haivision
                                                                 JS. Kim
                                                                 JW. Kim
                                                    SK Telecom Co., Ltd.
                                                        9 September 2020


                            The SRT Protocol
                      draft-sharabayko-mops-srt-01
```

# 概述
本文档规定了安全可靠传输 (SRT) 协议。
SRT 是基于UDP的用户级协议，为低延迟实时视频流提供可靠性和安全性优化，以及通用批量数据传输功能。为此，SRT 引入了控制包扩展、改进的流控、增强的拥塞控制和数据加密机制。

## 本备忘录的状态

本互联网草案的提交完全符合 BCP 78 和 BCP 79 的规定。

Internet-Drafts 是 Internet 工程任务组 (IETF) 的工作文件。请注意，其他小组也可以将工作文档作为 Internet-Drafts 分发。当前 Internet-Drafts 列表位于 https://datatracker.ietf.org/drafts/current/。

Internet-Drafts 是有效期最长为六个月的草稿文件，可以随时被其他文件更新、替换或作废。将 Internet-Drafts 用作参考材料或引用它们而不是“正在进行的工作”是不合适的。

该互联网草案将于 2021 年 3 月 13 日到期。

## 版权声明

版权所有 (c) 2020 IETF Trust 和文件作者。版权所有。

本文件受 BCP 78 和 IETF 信托关于 IETF 文件的法律规定 (https://trustee.ietf.org/license-info) 的约束，该条款在本文件发布之日生效。

请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文档中提取的代码组件必须包含 Trust Legal Provisions 第 4.e 节中所述的简化 BSD 许可文本，并且按照简化 BSD 许可中的说明在不保证的情况下提供。


# 1. 简介

## 1.1 动机

多年来，对实时视频流的需求一直在稳步增长。随着云技术的出现，许多视频处理组件已从本地设备过渡到在云上软件。虽然通过 RTMP [RTMP] 等基于 TCP 协议的实时流式传输，可在低比特率和小范围内实现，但流式传输市场的指数级增长催生了对更强大解决方案的需求。

为了提高交付端的可扩展性，内容交付网络 (CDN) 一度过渡到基于分段的技术，例如 HLS（HTTP 实时流媒体）[RFC8216] 和 DASH（HTTP 上的动态自适应流媒体）[ISO23009]。这一举措将实时流媒体的端到端延迟增加到 30 秒以上，这使得它对许多用例没有吸引力。随着时间的推移，业界优化了这些交付方式，将延迟降至 3 秒。

在交付规模扩大的同时，改进视频转码成为必要。观众在通过不同网络连接，在各种不同设备上观看视频流。由于来自本地位置的上传带宽通常是有限的，因此视频转码也转到了云端。

RTMP 成为通过公共 Internet 进行视频分发的实际标准。但其传输有效载荷是有限制的，RTMP 作为媒体特定协议仅支持两个音频通道和一组受限的音频和视频编解码器，缺乏对 HEVC [H.265]、VP9 [VP9] 或 AV1 [AV1] 等新格式的支持。

由于 RTMP、HLS 和 DASH 依赖于 TCP，这些协议只能在低 RTT 连接上实现可接受的可靠性；由于Tcp拥塞控制的限制，它们不能充分利用网络带宽。值得注意的是，QUIC[ID.ietf-quic-transport] 旨在解决 HTTP/3 [ID.ietf-quic-http] 中基于 HTTP 的交付协议的这些问题。
与 QUIC 一样，SRT [SRTSRC] 使用 UDP 而不是 TCP 传输协议，但使用自动重复请求 (ARQ)、数据包确认、端到端延迟管理等来确保更可靠的交付。

## 1.2 安全可靠的传输协议

 在可靠的 IP （通常是本地）网络上低延迟视频传输，通常采用 MPEG-TS [ISO13818-1] 单播或多播流的形式，使用 UDP/RTP 协议，其中任何数据包丢失都可以通过启用前向纠错来缓解(FEC)。在不同城市、国家甚至大洲的站之间实现相同的低延迟更具有挑战性。虽然可以使用卫星链路或专用 MPLS [RFC3031] 网络，但这些都是昂贵的解决方案。使用公共 Internet 连接虽然成本较低，但会增加大量带宽开销，用以实现必要的丢包恢复水平。为丢包恢复引入选择性包重传（可靠的 UDP）消除了这些限制。

SRT 源自基于 UDP的(UDT) 协议 [GHG04b]，是一种用户级协议，保留了大部分核心概念和机制，同时引入了一些改进和增强，包括控制包修改、改进的流控制以处理实时流、增强的拥塞控制和加密数据包的机制。

SRT 是一种传输协议，可在不可预测的网络（例如 Internet）上安全、可靠地传输数据。虽然任何数据类型都可通过 SRT 来传输，但它是低延迟（亚秒级）视频流的理想选择。与 RTMP 相比，SRT 提供了更高的带宽利用率，在长距离连接上允许更高的贡献比特率。

当数据包从源流向目标时，SRT 会检测并适应两个端点之间的实时网络状况，并有助于补偿由于嘈杂网络拥塞导致的抖动和带宽波动。它的错误恢复机制最大限度地减少了 Internet 连接中典型的数据包丢失。

为了实现低延迟流式传输，SRT 必须解决时序问题。来自源网络的流特性在通过公共 Internet 传输时会完全改变，这会引入延迟、抖动和数据包丢失。这反过来又会导致解码问题，因为音频和视频解码器不能在预期的时间接收数据包。使用大缓冲区会有所帮助，但会增加延迟。SRT 包括一种机制来保持恒定的端到端延迟，并在接收端重新创建信号特征，并减少对缓冲的需求。

与 TCP 一样，SRT 采用侦听器Listener/调用者Caller模型。数据流是双向的，并且独立于连接发起——发送者或接收者都可以作为监听者或调用者来发起连接。该协议提供内部多路复用机制，允许多个 SRT 连接共享同一个 UDP 端口，提供访问控制功能以在侦听器端识别调用者Caller。

SRT 支持前向纠错 (FEC) 和选择性数据包重传 (ARQ)，提供了使用这两种机制中的任何一种或两者结合使用的灵活性，允许使用从最低延迟到最高可靠性的用例。

SRT 保留了 UDT 中引入的快速文件传输能力，并增加了对 AES 加密的支持。

# 2. 术语和定义

关键词“必须”、“不得”、“要求”、“应”、“不得”、“应该”、“不应”、“推荐”、“不推荐”、“可以”和“可选”当且仅当它们以全部大写字母出现时，本文档中的 " 将按照 BCP 14 [RFC2119] [RFC8174] 中的描述进行解释，如此处所示。

- SRT：本文档描述的安全可靠传输协议。
- PRNG：伪随机数生成器。

# 3. 数据包结构

SRT 数据包作为 UDP 有效负载 [RFC0768] 来传输。每个承载 SRT 流量的 UDP 数据包，在 UDP 报头后都有一个 SRT 报头（图 1）。
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            SrcPort            |            DstPort            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              Len              |            ChkSum             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                          SRT Packet                           +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Figure 1: SRT packet as UDP payload
```
   SRT 有两种类型的数据包，由数据包类型标志区分：
   数据包和控制包。

   SRT 数据包结构如图 2 所示。
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+- SRT Header +-+-+-+-+-+-+-+-+-+-+-+-+-+
   |F|        (Field meaning depends on the packet type)           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          (Field meaning depends on the packet type)           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Destination Socket ID                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                        Packet Contents                        |
   |                  (depends on the packet type)                 +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                       Figure 2: SRT packet structure
```

- F：1位。数据包类型标志。
  - 控制包将此标志设置为“1”。
  - 数据包将此标志设置为“0”。
- Timestamp: 32 位。数据包的时间戳，以微秒为单位。该值与建立 SRT 连接的时间有关。根据传输模式（第 4.2 节），该字段存储数据包发送时间或数据包起始时间。
- Destination Socket ID: 32 位。一个固定宽度的字段，提供应向其分派数据包的 SRT 套接字 ID。当数据包是连接请求时，该字段可能具有特殊值“0”。

## 3.1 数据包

   SRT数据包结构如图3所示。
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+- SRT Header +-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|                    Packet Sequence Number                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |P P|O|K K|R|                   Message Number                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Destination Socket ID                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                              Data                             +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 3: Data packet structure
```
  - Packet Sequence Number：31 位。数据包序号。
  - PP：2 位。数据包位置标志。该字段指示数据包在消息中的位置。
    * “10b”（二进制）表示消息的第一个数据包。
    * “00b” 表示中间的包。
    * “01b” 表示最后一个数据包。
    * 如果单个数据包形成整个消息，则值为“11b”。
  - O：1位。有序标志。指示消息是否应该由接收者按顺序传递(1) 或不 (0) 。某些限制取决于所使用的数据传输模式（第 4.2 节）。
  - KK：2位。基于密钥的加密标志。标志位指示数据是否被加密。
    * “00b”（二进制）表示数据未加密。
    * “01b” 表示用偶数密钥加密数据，
    * “10b” 用于奇数密钥加密。请参阅第 5 节。
    * “11b” 仅用于控制包。
  - R：1位。重传数据包标志。
    * 当第一次发送数据包时，该标志是清除的。
    * 当重新发送数据包时，该标志设置为“1”。
  - Message Number: 26 位。形成消息的连续数据包的连续数（见 PP 字段）。
  - Timestamp: 32 位。见第 3 节。
  - Destination Socket ID: 32 位。见第 3 节。
  - Data：可变长度。数据包的有效载荷。数据的长度是UDP数据包的剩余长度。

## 3.2 控制包

   SRT 控制包具有以下结构。
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+- SRT Header +-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|         Control Type        |            Subtype            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Type-specific Information                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Destination Socket ID                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+- CIF -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                   Control Information Field                   +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Figure 4: Control packet structure
```
- Control Type:  15 位。控制包类型。详见表 1。
- Subtype: 16 位。此字段指定特定数据包的附加子类型。见表 1。
- Type-specific Information：32 位。该字段的使用取决于特定的控制包类型。握手包不使用该字段。
- Timestamp: 32 位。见第 3 节。
- Destination Socket ID: 32 位。见第 3 节。
- 控制信息字段 (CIF)：可变长度。该字段的使用由控制包的Control Type字段定义。

   SRT控制包的类型如表1所示。值“0x7FFF”是为用户定义的类型保留的。

| Packet Type       | Control Type | Subtype | Section       |
|-------------------|--------------|---------|---------------|
| HANDSHAKE         |    0x0000    |   0x0   | Section 3.2.1 |
| KEEPALIVE         |    0x0001    |   0x0   | Section 3.2.3 |
| ACK               |    0x0002    |   0x0   | Section 3.2.4 |
| NAK (Loss Report) |    0x0003    |   0x0   | Section 3.2.5 |
| SHUTDOWN          |    0x0005    |   0x0   | Section 3.2.6 |
| ACKACK            |    0x0006    |   0x0   | Section 3.2.7 |
| User-Defined Type |    0x7FFF    |    -    | N/A           |

                    表 1：SRT 控制包类型

### 3.2.1 Handshake

   握手控制包（Control Type = 0x0000）用于交换对等配置、就连接参数达成一致以及建立连接。

   握手控制包的控制信息字段 (CIF) 如图 5 所示。

```
   0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            Version                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Encryption Field       |        Extension Field        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Initial Packet Sequence Number                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Maximum Transmission Unit Size                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Maximum Flow Window Size                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Handshake Type                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         SRT Socket ID                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           SYN Cookie                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                        Peer IP Address                        +
   |                                                               |
   +                                                               +
   |                                                               |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |         Extension Type        |        Extension Length       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                       Extension Contents                      +
   |                                                               |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

                    Figure 5: Handshake packet structure
```
-  Version：32 位。基本协议版本号。当前使用的值为 4 和 5。大于 5 的值保留供将来使用。
-  加密字段：16 位。分组密码族和密钥大小。该字段的值在表 2 中描述。默认值为 AES-128。

| Value | Cipher family and key size |
|------ |----------------------------|
| 0     |  No Encryption Advertised  |
| 2     |          AES-128           |
| 3     |          AES-192           |
| 4     |          AES-256           |

 表 2：握手加密字段值

-  扩展字段：16 位。该字段是与握手类型字段相关的消息特定扩展。除以下情况外，该值必须设置为 0。
  (1) 如果握手控制包是 INDUCTION 消息，该字段由监听器发回。
  (2) 在CONCLUSION消息的情况下，该字段值应包含扩展类型值的组合。有关详细信息，请参阅第 4.3.1 节。

| Bitmask    |  Flag  |
|------------|--------|
| 0x00000001 | HSREQ  |
| 0x00000002 | KMREQ  |
| 0x00000004 | CONFIG |

表 3：握手扩展标志

-  初始数据包序列号：32 位。要发送的第一个数据包的序列号。
-  最大传输单元大小：32 位。此值通常设置为 1500，这是以太网的默认最大传输单元 (MTU) 大小，但可以更小。
-  最大流窗口大小：32 位。该字段的值是允许“in flight”的最大数据包数（即尚未收到 ACK 控制包的已发送数据包数）
-  握手类型: 32 位。该字段表示握手包类型。可能的值在表 4 中描述。有关详细信息，请参阅第 4.3 节。

| Value      | Handshake type |
|------------|----------------|
| 0xFFFFFFFD |      DONE      |
| 0xFFFFFFFE |   AGREEMENT    |
| 0xFFFFFFFF |   CONCLUSION   |
| 0x00000000 |    WAVEHAND    |
| 0x00000001 |   INDUCTION    |

   表 4：握手类型

-  SRT 套接字 ID：32 位。该字段保存发出握手包的源 SRT 套接字ID。
-  SYN Cookie：32 位。处理握手的随机值。该字段的值由握手消息类型指定。请参见第 4.3 节。
-  对端IP地址：128 位。数据包发送者的 IPv4 或 IPv6 地址。该值由四个 32 位字段组成。对于 IPv4 地址，字段 2、3 和 4 用零填充。
-  扩展类型: 16 位。该字段的值用于处理集成握手。每个扩展都可以有一对请求和响应类型。

| Value |   Extension Type   | HS Extension Flag |
|-------|--------------------|-------------------|
| 1     |   SRT_CMD_HSREQ    |       HSREQ       |
| 2     |   SRT_CMD_HSRSP    |       HSREQ       |
| 3     |   SRT_CMD_KMREQ    |       KMREQ       |
| 4     |   SRT_CMD_KMRSP    |       KMREQ       |
| 5     |    SRT_CMD_SID     |       CONFIG      |
| 6     | SRT_CMD_CONGESTION |       CONFIG      |
| 7     |   SRT_CMD_FILTER   |       CONFIG      |
| 8     |   SRT_CMD_GROUP    |       CONFIG      |

表 5：握手扩展类型值

- 扩展长度：16 位。以四字节为单位的扩展内容字段的长度。
- 扩展内容：可变长度。扩展的有效负载。

#### 3.2.1.1.  Handshake Extension Message

在握手扩展中，握手控制包的扩展字段的值
- 对于握手扩展请求（表 5 中的 SRT_CMD_HSREQ）定义为 1，
- 对于握手扩展响应（表 5 中的 SRT_CMD_HSRSP）定义为 2。

   握手扩展消息的扩展内容字段结构如下：
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          SRT Version                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           SRT Flags                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Receiver TSBPD Delay     |       Sender TSBPD Delay      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

              Figure 6: Handshake Extension Message structure
```

- SRT 版本：32 位。SRT 库版本必须形成为主要 * 0x10000 + 次要 * 0x100 + 补丁。
- SRT Flags: 32 位。SRT 配置标志（参见第 3.2.1.1.1 节）。
- 接收器 TSBPD 延迟：16 位。接收器的基于时间戳的数据包传递 (TSBPD) 延迟。请参阅第 4.5 节。
- 发送方 TSBPD 延迟：16 位。发件人的 TSBPD。请参阅第 4.5 节。

3.2.1.1.1.  Handshake Extension Message Flags

| Bitmask    |      Flag     |
|------------|---------------|
| 0x00000001 |    TSBPDSND   |
| 0x00000002 |    TSBPDRCV   |
| 0x00000004 |     CRYPT     |
| 0x00000008 |   TLPKTDROP   |
| 0x00000010 |  PERIODICNAK  |
| 0x00000020 |   REXMITFLG   |
| 0x00000040 |     STREAM    |
| 0x00000080 | PACKET_FILTER |

Table 6: Handshake Extension Message Flags

   * TSBPDSND 标志定义是否使用 TSBPD 机制（第 4.5 节）进行发送。
   * TSBPDRCV 标志定义 TSBPD 机制（第 4.5 节）是否将用于接收。
   * 必须设置 CRYPT 标志。它是一个遗留标志，表明该方理解 SRT 数据包的 KK 字段（图 3）。
   * TLPKTDROP 标志应该被设置，如果太迟丢包机制将在传输过程中使用。请参见第 4.6 节。
   * PERIODICNAK 标志设置表示对等方将定期发送 NAK 数据包。请参见第 4.8.2 节。
   * 必须设置 REXMITFLG 标志。这是一个传统标志，表明对等方理解 SRT 数据包的 R 字段（图 3）。
   * STREAM 标志标识要在连接中使用的传输模式（第 4.2 节）。如果设置了标志，将使用缓冲模式（第 4.2.3 节）。否则，将使用消息模式（第 4.2.1 节）。
   * PACKET_FILTER 标志表明对端是否支持包过滤。

#### 3.2.1.2.  Key Material Extension Message

   如果正在建立加密连接，则首先将Key Material (KM) 作为握手扩展消息传输。此扩展不提供给未受保护的连接。扩展的目的是让对等方交换和协商用于加密和解密流的有效负载的加密相关信息。

   可以通过设置为 SRT_CMD_KMREQ 或 SRT_CMD_HSRSP 的握手扩展类型字段来提供扩展（参见第 3.2.1 节中的表 5）。有关详细信息，请参阅第 4.3 节。
    KM 消息放置在扩展内容中。KM 消息的结构见第 3.2.2 节。

#### 3.2.1.3.  Stream ID Extension Message

   Stream ID 握手扩展消息可用于识别流内容。Stream ID 值可以是自由格式，但也有一个可用于实现互操作性的推荐约定。
   Stream ID 握手扩展消息具有 SRT_CMD_SID 扩展类型（见表 5。扩展内容为 UTF-8 字符序列。StreamID 扩展允许的最大大小为 512 字节。
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   |                           Stream ID                           |
                                  ...
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 7: Stream ID Extension Message
```
   Extension Contents 字段包含一个 UTF-8 字符序列（参见图 7）。StreamID 扩展允许的最大大小为 512 字节。实际大小由扩展长度字段（图 5）确定，该字段定义了四个字节长度。如果实际有效负载小于声明长度，则剩余字节设置为零。

   内容存储为 32 位小端字。

#### 3.2.1.4.  Group Membership Extension

   组成员握手扩展用于区分单个 SRT 连接和绑定 SRT 连接（组连接）。
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Group ID                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type    |     Flags     |             Weight              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                Figure 8: Group Membership Extension Message
```
- GroupID：32 位。组标识符，其成员包括正在建立连接的发送方套接字。应该解释它的目标套接字应该属于其一侧的相应组（或者应该创建一个，如果它不存在）。
- Type: 8 位。组类型，根据 SRT_GTYPE_ 枚举。
   * 0：未定义的组类型，
   * 1：广播组类型，
   * 2：主/备份组类型
   * 3：平衡组类型（保留以备将来使用）
   * 4：多播组类型（保留以备将来使用）

- Flags: 8 位。主要为未来保留的特殊标志。请参见下图
  * M：1位。设置时，定义消息编号的同步，否则传输在序列号上同步。
```
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+
   |   (zero)  |M|
   +-+-+-+-+-+-+-+
```

- Weight：16 位。特殊值的解释取决于类型字段值。
   * 不适用于广播组。
   * 定义备份组中的链路优先级。
   * 对于任何其他情况，尚未定义（留待将来使用）。


### 3.2.2 Key Material

   Key Material消息的目的是让对等方交换与加密相关信息，以用于加密和解密流的有效负载。

   可通过两种方式提供此消息：
   * 作为握手扩展，请参阅第 3.2.1.2 节，
   * 在用户定义的控制包的内容信息字段中（如下所述）。

   当 Key Material 作为控制包传输时，SRT 包头的 Control Type 字段设置为 User-Defined Type（见表 1），包头的 Subtype 字段设置为 SRT_CMD_KMREQ 用于密钥刷新请求和 SRT_CMD_KMRSP用于键刷新响应（表 5）。KM 刷新机制在第 5.1.6 节中描述。

   Key Material消息结构如图 10 所示。

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |S|  V  |   PT  |              Sign             |   Resv1   | KK|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              KEKI                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Cipher    |      Auth     |       SE      |     Resv2     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Resv3             |     SLen/4    |     KLen/4    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              Salt                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                          Wrapped Key                          +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                 Figure 10: Key Material Message structure
```
  - S：1 位，值 = {0}。这是一个固定宽度的字段，保留供将来使用。
  - 版本 (V)：3 位，值 = {1}。这是一个固定宽度的字段，指示 SRT 版本：
      * 1：初始版本

  - 包类型 (PT)：4 位，值 = {2}。这是指示数据包类型的固定宽度字段：
      * 0：保留
      * 1：媒体流消息（MSmsg）
      * 2：Key Material消息（KMmsg）
      * 7：保留用于区分 MPEG-TS 数据包（0x47=同步字节）

  - Sign：16 位，值 = {0x2029}。这是一个固定宽度的字段，包含编码为 PnP 供应商 ID ([PNPID]) 的签名“HAI”（按大端顺序）
  - Resv1：6 位，值 = {0}。这是为标志扩展或其他用途保留的固定宽度字段。
  - Key-based Encryption (KK)：2 位。这是一个固定宽度的字段，指示扩展中提供了哪些 SEK（奇数和/或偶数）：
      * 00b：没有提供 SEK（无效的扩展格式）
      * 01b：提供偶数键
      * 10b：提供奇数键
      * 11b：提供偶数和奇数键

   - Key Encryption Key Index (KEKI)：32 位，值 = {0}。这是用于指定 KEK 索引（大端顺序）的固定宽度字段，用于包装（和可选地验证）SEK。值 0 用于表示当前流的默认键。
      保留其他值以供将来可能使用密钥管理系统检索加密上下文。
      * 0：默认流关联键（流/系统默认）
      * 1..255：为手动索引键保留

   - Cipher：8 位，值 = {0..2}。这是用于指定加密密码和模式的固定宽度字段：
      * 0：无或 KEKI 索引加密上下文
      * 2：AES-CTR [SP800-38A]

   - 身份验证 (Auth)：8 位，值 = {0}。这是用于指定消息验证码算法的固定宽度字段：
      * 0：无或 KEKI 索引加密上下文

   - 流封装 (SE)：8 位，值 = {2}。这是一个用于描述流封装的固定宽度字段：
      * 0：未指定或 KEKI 索引的加密上下文
      * 1：MPEG-TS/UDP
      * 2：MPEG-TS/SRT

   - Resv2：8 位，值 = {0}。这是一个固定宽度的字段，保留供将来使用。
   - Resv3：16 位，值 = {0}。这是一个固定宽度的字段，保留供将来使用。
   - SLen/4：8 位，值 = {4}。这是一个固定宽度字段，用于指定Salt长度 SLen（以字节为单位）除以 4。如果不存在Salt/- IV，则可以为零。定义的Salt的唯一有效长度是 128 位。
   - Klen/4：8 位，值 = {4,6,8}。这是一个固定宽度字段，用于指定 SEK 长度（以字节为单位除以 4）。即使存在两个密钥，一个密钥的大小。必须与握手包表 2 的加密字段中指定的密钥大小相匹配。
   - Salt（SLen）：SLen * 8 位，值 = { }。这是一个可变宽度字段，通过指定Salt键来补充键控材料。
   - Wrap：(64 + n * KLen * 8) 位，值 = { }。这是用于指定 Wrapped key(s) 的可变宽度字段，其中 n = (KK + 1)/2 且 wrap 字段的大小为 ((n * KLen) + 8) 字节。
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                  Integrity Check Vector (ICV)                 +
   |                                                               |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                              xSEK                             |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                              oSEK                             |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

                     Figure 11: Unwrapped key structure
```
   - ICV：64 位。64 位完整性检查向量（AES 密钥包装完整性）。该字段用于检测密钥是否被正确解包。如果手中的 KEK 无效，则验证失败并丢弃未包装的密钥。
   - xSEK：可变宽度。此字段标识奇数或偶数 SEK。如果只存在一个密钥，则在 KK 字段中设置的位会告知提供了哪个 SEK。如果两个键都存在，则此字段为 eSEK（偶数键），其后是奇数键 oSEK。该字段的长度计算为 KLen * 8。

   - oSEK：可变宽度。只有当消息携带两个 SEK（由他的 KK 字段标识）时，才会出现这个带有奇数键的字段。


### 3.2.3.  Keep-Alive

   自上次发送任何数据包（控制或数据）后的某个超时后，将发送保活控制包。此控制包的目的是通知对等方在没有数据交换时，保持连接打开。

   发送保活数据包的默认超时为 1 秒。

   SRT 保活数据包格式如下：
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+- SRT Header +-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|         Control Type        |            Reserved           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Type-specific Information                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Destination Socket ID                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Figure 12: Keep-Alive control packet
```
- Control Type:  15 位，值 = KEEPALIVE{0x0001}。保活控制包的Control Type值为“1”。
- Reserved：16 位，值 = 0。这是为将来使用保留的固定宽度字段。
- Type-specific Information.。该字段保留供将来定义。
- Timestamp: 32 位。见第 3 节。
- Destination Socket ID: 32 位。见第 3 节。

 Keep-Alive控制包不包含控制信息字段（CIF）。

### 3.2.4 ACK（确认）

   确认控制包用于提供数据包的传递状态。通过确认数据包的接收直到（知道）确认的数据包序列号，接收方通知发送方所有先前的数据包都已收到，或者，在实时传输模式（第 4.2.2 节）下，如果有任何丢失的数据包被丢弃，则为时已晚交付。

   ACK 包还可能携带一些来自接收方的附加信息，如 RTT、带宽、接收速度等。ACK 控制包的 CIF 部分扩展如下：
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+- SRT Header +-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|        Control Type         |           Reserved            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgement Number                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Destination Socket ID                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+- CIF -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Last Acknowledged Packet Sequence Number           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              RTT                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          RTT Variance                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Available Buffer Size                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Packets Receiving Rate                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Estimated Link Capacity                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Receiving Rate                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                       Figure 13: ACK control packet
```
 - Control Type:  15 位，值 = ACK{0x0002}。ACK控制包的Control Type值为“2”。
 - Reserved：16 位，值 = 0。这是为将来使用保留的固定宽度字段。
 - Acknowledgement Number：32 位。该字段包含从 1 开始的Full Ack包的序号。
 - Timestamp: 32 位。见第 3 节。
 - Destination Socket ID: 32 位。见第 3 节。
 - Last Acknowledged Packet Sequence Number：32 位。该字段包含被确认的最后一个数据包的序列号加一。换句话说，它是第一个未确认数据包的序列号。
 - RTT：32 位。RTT 值，以微秒为单位，由接收器根据先前的 ACK-ACKACK 数据包交换估计。
 - RTT 方差：32 位。RTT 估计的方差，以微秒为单位。
 - 可用缓冲区大小：32 位。接收方缓冲区的可用大小，以数据包为单位。
 - 数据包接收速率：32 位。接收数据包的速率，以每秒数据包为单位。
 - 估计的链路容量：32 位。链路的估计带宽，以每秒数据包为单位。
 - 接收速率：32 位。估计的接收速率，以每秒字节数为单位。

   ACK包有几种Type: 
   * 每 10 ms 发送一个Full ACK 控制包，并具有图 13 上的所有字段。
   * Lite ACK 控制包仅包含 Last Acknowledged Packet Sequence Number 字段。Acknowledgement Number 字段应设置为 0。
   * Small ACK 包括直到可用缓冲区大小字段并包括在内的字段。Acknowledgement Number字段应设置为 0。

   发送方仅确认收到Full ACK 数据包（参见 ACKACK 第 3.2.7 节）。

   Lite ACK 和 Small ACK 数据包用于接收器应比每 10 ms 更频繁地确认接收到的数据包的情况。这通常在高数据速率下需要。由接收方决定要发送的 ACK 数据包的条件和类型（Lite 或 Small）。建议每收到 64 个数据包发送一个 Lite ACK。

### 3.2.5.  NAK (Loss Report)

   否定确认 (NAK) 控制包用于指示数据包传递失败。接收方通过发送包含丢失数据包序列号列表的 NAK 数据包来通知发送方有关丢失数据包的信息。

   SRT NAK 数据包的格式如下：
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+- SRT Header +-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|        Control Type         |           Reserved            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Type-specific Information                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Destination Socket ID                     |
   +-+-+-+-+-+-+-+-+-+-+-+- CIF (Loss List) -+-+-+-+-+-+-+-+-+-+-+-+
   |0|                 Lost packet sequence number                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|         Range of lost packets from sequence number          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|                    Up to sequence number                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|                 Lost packet sequence number                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                       Figure 14: NAK control packet
```
 - Control Type:  15 位，值 = NAK{0x0003}。NAK控制包的Control Type值为“3”。
 - Reserved：16 位，值 = 0。这是为将来使用保留的固定宽度字段。
 - Type-specific Information：32 位。该字段保留供将来定义。
 - Timestamp: 32 bits.  See Section 3.
 - Destination Socket ID: 32 bits.  See Section 3.
   控制信息字段 (CIF)。单个值或一系列丢失的数据包序列号。参见附录 A 中的分组序列号编码。

### 3.2.6.  Shutdown

   关闭控制包用于启动 SRT 连接的关闭。

   SRT Shutdown包的格式如下：
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+- SRT Header +-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|        Control Type         |           Reserved            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Type-specific Information                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Destination Socket ID                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Figure 15: Shutdown control packet
```
  - Control Type:  15 位，值 = SHUTDOWN{0x0005}。关机控制包的Control Type值为“5”。
  - Timestamp: 32 位。见第 3 节。
  - Destination Socket ID: 32 位。见第 3 节。
  - 特定于类型的信息。该字段保留供将来定义。
   关闭控制包不包含控制信息字段（CIF）。

### 3.2.7  ACKACK

   发送 ACKACK 控制包以确认接收到 Full ACK，并用于接收方计算 RTT。

   SRT ACKACK 控制包的格式如下：
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+- SRT Header +-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|        Control Type         |           Reserved            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Acknowledgement Number                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Destination Socket ID                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 16: ACKACK control packet
```
  - Control Type:  15 位，值 = ACKACK{0x0006}。ACKACK控制包的Control Type值为“6”。
  - Acknowledgement Number: 此字段包含Full ACK 数据包的确认编号，该 ACKACK 数据包正在确认其接收。
  - Timestamp: 32 位。见第 3 节。
  - Destination Socket ID: 32 位。见第 3 节。

   ACKACK 控制包不包含控制信息字段（CIF）。

# 4. SRT数据传输与控制

   本节介绍与在传输过程中处理控制和数据包相关的关键概念。

   握手和能力交换完成后，可以通过已建立的连接发送和接收数据包了。为了充分利用 SRT 提供的低延迟和错误恢复特性，发送方和接收方必须按照本节的规定处理连接的控制包、定时器和缓冲区。

## 4.1 流复用

   多个 SRT 套接字可以共享同一个 UDP 套接字，以便接收到此 UDP 套接字的数据包将正确地分派到它们当前指定的那些 SRT 套接字。

   在握手期间，双方交换他们的 SRT Socket ID。这些 ID 之后用于每个控制和数据包的目标套接字 ID 字段（见第 3 节）。

## 4.2 数据传输模式

   SRT 主要是为实时流媒体创建的，因此它的主要和默认传输模式是“Live Mode”。但是，SRT 支持原始 UDT 库支持的模式，即Buffer Mode和Message Mode。

### 4.2.1 Message Mode

   当握手扩展消息第 3.2.1.1 节的 STREAM 标志设置为 0 时，协议工作在消息模式，其特征如下：

   * 每个数据包都有自己的数据包序列号。
   * 一个或几个连续的 SRT 数据包可以形成一个消息。
   * 属于同一消息的所有数据包在消息编号字段中设置了相同的消息编号。

   消息的第一个数据包的数据包位置标志（第 3.1 节）的第一位设置为 1。消息的最后一个数据包的数据包位置标志的第二位设置为 1。因此，PP等于“11b”表示形成整个消息的分组。PP等于“00b”表示属于消息内部的分组。

   SRT 中消息的概念来自 UDT ([GHG04b])。在这种模式下，一条发送指令恰好传递一条有边界的数据（一条消息）。此消息可能跨越多个 UDP/SRT 数据包。唯一的大小限制是它应该作为一个整体适合发送者和接收者的缓冲区。尽管在内部对数据包的所有操作（例如ACK、NAK）都是独立执行的，但应用程序必须发送和接收整个消息。在消息完成（收到所有数据包）之前，不允许应用程序读取它。

   当数据包的 Order Flag 设置为 1 时，这会对消息施加顺序读取限制。设置为 0 的 Order Flag 允许应用程序在可能丢失某些数据包的任何先前消息之前，读取已经完全可用的消息（乱序读取）。

### 4.2.2 Live Mode

   实时模式是一种特殊类型的消息模式，其中只允许 PP 字段设置为“11b”的数据包。

   此外，在此模式下使用基于时间戳的数据包传递 (TSBPD)（第 4.5 节）和Too late的数据包丢弃（第 4.6 节）机制。

### 4.2.3 Buffer Mode

   通过将握手扩展消息标志的 STREAM 标志设置为 1，在握手期间协商缓冲区模式。

   在这种模式下，连续的数据包形成一个可以读取的连续流，能读取任意大小部分。

## 4.3 握手消息

   SRT 是一种面向连接的协议。它包含“连接”和“会话”的概念。SRT 使用 UDP 系统协议来发送数据和控制包。

   SRT 连接的特点是：

   * 首先参与握手过程；
   * 只要及时交换任何数据包，就可以保持；
   * 当一方从对方收到关闭命令（连接被外部主机关闭），或者当它在某个预定义的时间内没收到任何数据包（超时连接中断）时，就认为连接是关闭的。

   SRT 支持两种连接配置：

   1. Caller-Listener，一方等待另一方发起连接
   2. Rendezvous，双方都尝试发起连接


   握手在两方之间执行：“发起者”和“响应者”：

   * 发起者启动扩展 SRT 握手过程并发送适当的 SRT 扩展握手请求。
   * 响应者期望发起者发送 SRT 扩展握手请求，并返回 SRT 扩展握手响应。

   在握手中交换的 SRT 握手扩展有两种基本类型: 
   * 握手扩展消息交换基本SRT信息；
   * Key Material Exchange 交换封装的流加密密钥（仅在请求加密时使用）。
   * Stream ID 扩展交换一些特定于流的信息，应用程序可以使用这些信息来识别传入的流连接。

   根据连接模式分配发起者Initiator和响应者Responder角色。

   对于 Caller-Listener 连接：Caller 是 Initiator，Listener 是 Responder。
   对于 Rendezvous 连接：根据握手期间的初始数据交换，分配发起者和响应者角色。

   握手结构中的握手类型字段（参见图 5）指示握手消息类型。

   Caller-Listener 握手交换具有以下握手类型的顺序：

   1. Caller to Listener: INDUCTION
   2. Listener to Caller：INDUCTION（报告cookie）
   3. Caller to Listener：CONCLUSION（使用之前返回的cookie）
   4. Listener to Caller：CONCLUSION（确认连接建立）

   Rendezvous握手交换具有以下握手类型的顺序：

   1. 开始连接后：WAVEAHAND。
   2. 收到对端的上述消息后：CONCLUSION。
   3. 收到对端的上述消息后：AGREEMENT。

   当连接过程在任何一方可以发送CONCLUSION握手之前失败时，握手类型字段将包含被拒绝连接的适当错误值。请参阅表 7 中的错误代码列表。

| 代码 | 错误 | 说明 |
|--------|----------------|-----------------------------|
| 1000 | REJ_UNKNOWN | 不明原因 |
| 1001 | REJ_SYSTEM | 系统功能错误 |
| 1002 | REJ_PEER | 被同行拒绝 |
| 1003 | REJ_RESOURCE | 资源分配问题 |
| 1004 | REJ_ROGUE | 握手数据不正确|
| 1005 | REJ_BACKLOG | 听众的积压超出|
| 1006 | REJ_IPE | 内部程序错误 |
| 1007 | REJ_CLOSE | 套接字正在关闭|
| 1008 | REJ_VERSION | peer 比 agent 的 min 版本更旧 |
| 1009 | REJ_RDVCOOKIE | 会合 cookie 碰撞 |
| 1010 | REJ_BADSECRET | 密码错误 |
| 1011 | REJ_UNSECURE | 需要或意外密码 |
| 1012 | REJ_MESSAGEAPI | 流旗碰撞 |
| 1013 | REJ_CONGESTION | 不兼容的拥塞控制器类型|
| 1014 | REJ_FILTER | 不兼容的包过滤器|
| 1015 | REJ_GROUP | 不相容组 |

            表 7：握手拒绝原因代码

   密码族和块大小的规范由数据发送者决定。当传输是双向的时，这个值必须在一开始就达成一致，因为当两者都设置时，响应者获胜。对于 Caller-Listener 连接，仅在 Listener 上设置此值是合理的。在 Rendezvous 的情况下，唯一合理的方法是确定来自不同来源的正确值并将其设置在双方（注意 *AES-128* 是默认值）。

### 4.3.1.  Caller-Listener Handshake

   本节描述了侦听器在绑定的 UDP 端口上等待来自呼叫者的传入握手请求的握手过程。这个过程有两个阶段：INDUCTION 和CONCLUSION。

#### 4.3.1.1.  The Induction Phase

   INDUCTION 阶段仅用于在侦听器上设置一个 cookie，以便它不分配资源，从而减轻潜在的 DoS 攻击，该攻击可能通过使用握手命令淹没侦听器而实施。

   调用者首先发送 INDUCTION 握手，其中包含以下（重要）字段：

   * Version: MUST always be 4
   * Encryption Field: 0
   * Extension Field: 2
   * Handshake Type: INDUCTION
   * SRT Socket ID：调用者的SRT Socket ID
   * SYN Cookie：0

   该消息中SRT包头的Destination Socket ID为0，解释为连接请求。

   在此初始握手中，握手版本号设置为 4。这是由于 SRT 的初始设计符合其所基于的 UDT 协议 ([GHG04b])。

   侦听器响应以下内容：

   * Version: 5
   * Encryption Field: Advertised cipher family and block size.
   * Extension Field: SRT magic code 0x4A17
   * Handshake Type: INDUCTION
   * SRT Socket ID：监听器的Socket ID
   * SYN Cookie：基于主机、端口和当前时间制作的 cookie，精度为 1 分钟，以避免 SYN 泛洪攻击 [RFC4987]

   此时，Listener 仍然不知道 Caller 是 SRT 还是 UDT，并且无论 Caller 是 SRT 还是 UDT，它都会以相同的一组值进行响应。

   如果参与方是 SRT，它会解释版本和扩展字段中的值。如果它在 Version 中接收到值 5，它就知道它来自 SRT 方，因此它知道它应该准备适当的握手消息阶段。它还检查以下内容：

   * Extension Flags 是否包含魔法值 0x4A17；否则连接被拒绝。如果有人试图独立扩展 UDT，将 Version 值增加到 5 并尝试针对 SRT 进行测试，这是一种意外情况。
   * 加密标志是否包含非零值，该值被解释为广告密码族和块大小。

   旧的 UDT 方完全忽略版本和握手类型中报告的值。然而，它对 SYN Cookie 值感兴趣，因为它必须传递到下一阶段。它确实解释了这些字段，但仅在“CONCLUSION”消息中。

#### 4.3.1.2.  The Conclusion Phase

   一旦 Caller 从 Listener 获得 SYN cookie，它就会向 Listener 发送 CONCLUSION 握手。

   以下值由兼容的调用者设置：

   *  Version: 5
   *  Handshake Type: CONCLUSION
   *  SRT Socket ID: Socket ID of the Caller
   *  SYN Cookie: the cookie previously received in the induction phase

   此消息中的目标套接字 ID 是之前在握手结构的 SRT 套接字 ID 字段中的感应阶段收到的套接字 ID。

   * 加密Flags: 公布的密码系列和块大小。
   * 扩展Flags: 定义握手中提供的扩展的一组标志。

   侦听器使用上面显示的相同值进行响应，但没有 cookie（此处不需要），以及 HS 版本 5 的扩展（可能完全相同）。

   这里没有任何"negotiation"。如果握手中传递的值以任何方式不被对方接受，则连接将被拒绝。监听器可以优先于调用者的唯一情况是握手的加密字段中公布的密码族和块大小（表 2）。

   延迟值总是被认为是各方报告的值中的较大者。

### 4.3.2.  Rendezvous Handshake

   Rendezvous 进程使用状态机。它与 UDT Rendezvous 握手 [GHG04b] 略有不同，尽管它仍然基于相同的消息请求类型。

   双方都以 WAVEAHAND 开头，并使用版本值 5。
   旧版本 4 客户端不查看版本值，而版本 5 客户端可以检测版本 5。当双方的版本设置为 5 时，各方仅继续执行版本 5 集合点流程。否则，该过程仅根据版本 4 规则 [GHG04b] 继续。

   在第 5 版 Rendezvous 中，双方为称为“cookie contest”的流程创建一个 cookie。这对于分配发起者和响应者角色是必要的。每一方根据主机、端口和当前时间生成一个 cookie 值（一个 32 位数字），精度为 1 分钟。使用 MD5 和计算对该值进行加扰。然后将 cookie 值相互比较。

   由于同一台机器上不可能有两个套接字绑定到同一个 NIC 和端口并独立运行，因此双方几乎不可能生成相同的 cookie。但是，如果应用程序尝试“连接到自身”，即连接到本地 IP 地址（当套接字绑定到 INADDR_ANY 时）或连接到套接字绑定到的同一 IP 地址，则可能会发生这种情况。如果 cookie 相同（出于任何原因），则在生成新的唯一 cookie（最多延迟一分钟后）之前，不会建立连接。在应用程序“连接到自身”的情况下，cookie 将始终相同，因此永远不会建立连接。

   当一方的 cookie 值大于其对等方的值时，它将赢得 cookie contest并成为发起者（另一方成为响应者）。

   此时有两种可能的“握手流程”：串行和并行。

#### 4.3.2.1 串行握手流程

   在串行握手流程中，一方始终是第一方，另一方紧随其后。也就是说，虽然双方都在重复发送 WAVEAHAND 消息，但在某个时候，一方（比如说 Alice）会发现她在发送下一条消息之前已经收到了一条 WAVEAHAND 消息，因此她发送了一条 CONCLUSION 消息作为响应。同时，Bob（Alice 的同伴）错过了 Alice 的 WAVEAHAND 消息，因此 Alice 的 CONCLUSION 是 Bob 从她那里收到的第一条消息。

   这个过程可以很容易地描述为第一方和后续方（分别为 Alice 和 Bob）之间的一系列交换：

   1. 最初，双方都处于挥手状态。Alice 向 Bob 发送握手消息：

       * Version: 5
       * Type: Extension field: 0, Encryption field: advertised "PBKEYLEN".
       * Handshake Type: WAVEAHAND
       * SRT Socket ID：Alice 的套接字 ID
       * SYN Cookie：根据主机/端口和当前时间创建。

   虽然 Alice 还不知道她是在向第 4 版还是第 5 版对等方发送此消息，但当握手类型为 WAVEAHAND 时，第 4 版对等方不会解释来自这些字段的值。

   1. Bob 收到 Alice 的 WAVEAHAND 消息，切换到"attention"状态。由于 Bob 现在知道 Alice 的 cookie，因此他进行了“cookie contest”（比较两个 cookie 值）。如果 Bob 的 cookie 大于 Alice 的，他将成为发起者。否则，他将成为响应者。
   握手角色（发起者或响应者）的解析对于进一步处理至关重要。

   然后 Bob 回应:
   *  Version: 5
   *  Extension field: appropriate flags if Initiator, otherwise 0
   *  Encryption field: advertised PBKEYLEN
   *  Handshake Type: CONCLUSION

   如果 Bob 是发起者并且加密开启，他将使用他自己的密码族和块大小或从 Alice 那里收到的（如果她已经公布了这些值）。

   1. Alice 收到 Bob 的 CONCLUSION 消息。虽然此时她也进行了"cookie contest"，但结果是一样的。
       她切换到“fine”状态，并发送：

       *  Version: 5
       *  Appropriate extension flags and encryption flags
       *  Handshake Type: CONCLUSION

   此时双方总是发送扩展标志，如果消息来自 Initiator，则包含 HSREQ，如果来自 Responder，则包含 HSRSP。如果发起方从响应方收到先前的消息，在加密标志字段中包含通告的密码族和块大小，则它将用作在 KMREQ 扩展中下一次发送的密钥生成的密钥长度。

   1. Bob 收到 Alice 的 CONCLUSION 消息，然后执行以下操作之一（取决于 Bob 的角色）：
       * 如果 Bob 是发起者（Alice 的消息包含 HSRSP），他：
          - 切换到“连接”状态
          - 向 Alice 发送握手类型 AGREEMENT 的消息，但不包含 SRT 扩展（扩展标志字段应为 0）
       * 如果 Bob 是响应者（Alice 的消息包含 HSREQ），他：
          - 切换到"initiated"状态
          - 向 Alice 发送一条带有握手类型CONCLUSION的消息，该消息还包含带有 HSRSP 的扩展
             o 等待 Alice 确认她也已连接（最好通过 AGREEMENT 消息）
   2. Alice 收到上述消息，进入“connected”状态，然后执行以下操作之一（取决于 Alice 的角色）：
       * 如果 Alice 是发起者（收到 HSRSP 的 CONCLUSION），她会向 Bob 发送 Handshake Type = AGREEMENT 的消息。
       * 如果 Alice 是响应者，则接收到的消息具有握手类型 AGREEMENT，作为响应，她什么也不做。
   3. 此时，如果 Bob 是 Initiator，则他已经连接。如果他是 Responder，他应该收到上面的 AGREEMENT 消息，然后切换到“connected”状态。在带有协议消息的 UDP 数据包丢失的情况下，一旦 Bob 从 Alice 那里收到任何其他信息，他仍然会进入“连接”状态。然而，如果 Bob 要发送，他必须继续发送相同的 CONCLUSION，直到他得到 Alice 的确认。

#### 4.3.2.2 并行握手流程

   并行握手流的机会非常低，但是如果两个对等点同时发送和接收带有 WAVEAHAND 的握手消息，它仍然可能发生。

   生成的流程非常类似于 Bob 在串行握手流程中的行为，但对双方来说都是如此。Alice 和 Bob 将经历相同的状态转换：

   挥手->注意->发起->连接
   Waving -> Attention -> Initiated -> Connected

   在注意状态下，他们知道彼此的 cookie，因此他们可以分配角色。与主要基于请求-响应周期的串行流相比，这里一切都发生了

   异步：在接收到具有适当内容的特定握手消息时状态切换（发起者必须附加 HSREQ 扩展，响应者必须附加“HSRSP”扩展）。

   以下是基于角色的并行握手流程的工作方式：

   发起人：

   1.  Waving
       *  Receives WAVEAHAND message
       *  Switches to Attention
       *  Sends CONCLUSION + HSREQ

   2.  Attention
       *  Receives CONCLUSION message, which:
          -  contains no extensions:
             o  switches to Initiated, still sends CONCLUSION + HSREQ
          -  contains "HSRSP" extension:
             o  switches to Connected, sends AGREEMENT

   3.  Initiated
       *  Receives CONCLUSION message, which:
          -  Contains no extensions:
             o  REMAINS IN THIS STATE, still sends CONCLUSION + HSREQ
          -  contains "HSRSP" extension:
             o  switches to Connected, sends AGREEMENT

   4.  Connected
       * 可能会收到 CONCLUSION 并以 AGREEMENT 响应，但通常到现在它应该已经收到了有效负载数据包。

   响应者：

   1.  Waving
       *  Receives WAVEAHAND message
       *  Switches to Attention
       *  Sends CONCLUSION message (with no extensions)

   2.  Attention
       * 接收带有 HSREQ 的 CONCLUSION 消息。此消息可能不包含扩展，在这种情况下，该方应像以前一样简单地发送空的 CONCLUSION 消息，并保持在此状态。
       * 切换到 Initiated 并使用 HSRSP 发送 CONCLUSION 消息

   3.  Initiated
       *  Receives:
          -  CONCLUSION message with HSREQ
             o  responds with CONCLUSION with HSRSP and remains in this state
          -  AGREEMENT message
             o  responds with AGREEMENT and switches to Connected
          -  Payload packet
             o  responds with AGREEMENT and switches to Connected

   4.  Connected
       * 不再期望收到任何握手消息。AGREEMENT 消息总是只发送一次或每个最终的 CONCLUSION 消息。

   请注意，这些数据包中的任何一个都可能丢失，并且发送方永远不会意识到这一点。丢失数据包问题是这样解决的：

   1. 如果 Responder 错过了 CONCLUSION + HSREQ 消息，它只是继续发送空的 CONCLUSION 消息。只有在收到 CONCLUSION + HSREQ 时，它才会以 CONCLUSION + HSRSP 响应。
   2. 如果 Initiator 错过了 Responder 的 CONCLUSION + HSRSP 响应，它会继续发送 CONCLUSION + HSREQ。当发起方发送 CONCLUSION + HSREQ 时，响应方必须始终以 CONCLUSION + HSRSP 进行响应，即使它已经收到并解释了它。
   3. 当 Initiator 切换到 Connected 状态时，它会以 AGREEMENT 消息进行响应，Responder 可能会错过该消息。
       尽管如此，Initiator 可能会开始发送数据包，因为它认为自己已连接 - 它不知道 Responder 尚未切换到 Connected 状态。因此，例外情况是，当 Responder 处于 Initiated 状态并通过该连接接收到数据包（或任何通常仅在连接方之间发送的控制包）时，它可以切换到 Connected 状态，就像它收到了一样协议消息。
   4. 如果 Initiator 已经切换到 Connected 状态，它不会再用任何握手消息打扰 Responder。但是响应者可能完全没有意识到这一点（错过了来自发起者的 AGREEMENT 消息）。因此它不会退出连接状态，这意味着它会继续发送 CONCLUSION + HSRSP 消息，直到它接收到任何使其切换到连接状态（通常为 AGREEMENT）的数据包。只有这样它才会退出连接状态，应用程序才能开始传输。

## 4.4 SRT 缓冲区延迟

   SRT 发送方和接收方设有缓冲区来存储数据包。

   在发送方，延迟是 SRT 持有数据包以使其有机会成功传送的时间，同时保持发送方在接收方的速率。如果确认 (ACK) 丢失或延迟超过配置的延迟，则从发送缓冲区丢弃数据包。只要数据包在延迟窗口期间，都保留在缓冲区中，就可重传数据包。在接收器上，经过延迟间隔后，数据包从缓冲区传送到应用程序。这有助于从潜在的数据包丢失中恢复。有关详细信息，请参阅第 4.5 节、第 4.6 节。

   延迟是一个以毫秒为单位的值，它可以涵盖以高比特率传输数百甚至数千个数据包的时间。
   延迟可以被认为是一个随时间滑动的窗口，在此期间会发生许多活动，例如报告已确认数据包（ACK）（第 4.8.1 节）和未确认数据包（NAK）（第 4.8.2 节） .

   延迟是通过在发起者和响应者之间的扩展握手过程中交换能力来配置的。握手扩展消息（第 3.2.1.1 节）具有来自 SRT 接收器和发送器的 TSBPD 延迟信息，以毫秒为单位。连接的延迟将被设成发起者和响应者提出的延迟的最大值。

## 4.5 基于时间戳的数据包传递

   SRT 基于时间戳的数据包传递 (TSBPD) 机制的目标是在实时数据传输模式下，在接收应用程序（例如解码器）的输入端再现发送应用程序（例如编码器）的输出（参见第 4.2 节）. 它试图重现发送应用程序向 SRT 发送者提交数据包的时间。这允许 SRT 接收器安排数据包的传送，使它们准备好被接收应用程序读取（参见图 17）。

   SRT 接收器使用 SRT 数据包头的时间戳，将数据包传送到接收应用程序，从数据包在 SRT 发送方安排发送的时间起，具有固定的最小延迟。基本上，在将数据包释放给应用程序之前，将接收数据包中的发送者时间戳调整为接收者的本地时间（补偿时间漂移或不同时区）。SRT 接收器可以为配置的接收器延迟保留数据包。更高的延迟可以适应更大的统一数据包丢弃率，或更大的数据包突发丢弃。如果启用了Tool Late丢包功能（参见第 4.6 节），则在其“播放时间”之后收到的数据包将被丢弃。

   数据包时间戳（以微秒为单位）与 SRT 连接创建时间相关。数据包根据标头字段中的序列号插入。除非明确提供，否则当应用程序首次将数据包提交给 SRT 发送方时，数据包的原始时间（以微秒为单位）已被采样。TSBPD 功能使用此时间标记数据包以进行首次传输和任何后续重传。此时间戳和配置的 SRT 延迟（第 4.4 节）控制恢复缓冲区的大小和数据包在目的地传送的时刻（上述“播放时间”通过将时间戳添加到配置的延迟来决定）。

   值得一提的是，使用数据包发送时间来标记数据包对于 TSBPD 特性是不合适的，因为重新传输的数据包使用了一个新的时间（当前发送时间），当插入到它们的正确位置时它们会乱序。流。

   图 17 显示了启用 TSBPD 功能的数据包传输过程中的关键延迟点。
```
                 |  Sending  |              |                   |
                 |   Delay   |    ~RTT/2    |    SRT Latency    |
                 |<--------->|<------------>|<----------------->|
                 |           |              |                   |
                 |           |              |                   |
                 |           |              |                   |
       ___ Scheduled       Sent         Received           Scheduled
      /    for sending       |              |              for delivery
   Packet        |           |              |                   |
   State         |           |              |                   |
                 |           |              |                   |
                 |           |              |                   |
                 ----------------------------------------------------->
                                                                   Time

        Figure 17: Key Latency Points during the Packet Transmission
```
   图 17 中显示的主要数据包状态如下：

   * “Scheduled for sending”：数据包由发送应用程序提交，标记并准备发送；
   * “Sent”：数据包被传递到UDP套接字并发送；
   * "Received"：从 UDP 套接字接收和读取数据包；
   * “Scheduled for Delivery”：数据包已安排好交付并准备好被接收应用程序读取。

   值得注意的是，SRT 链路的往返时间 (RTT) 可能会随时间变化。然而，一旦发生 SRT 握手交换，链路上的实际端到端延迟变得固定，大约等于 (RTT_0/2 + SRT 延迟)，其中 RTT_0 是 SRT 握手期间往返时间的实际值交换（SRT 连接建立后的往返时间值）。

   发送延迟的值取决于硬件性能。与以毫秒为单位的 RTT_0/2 和 SRT 延迟相比，它通常相对较小（几微秒）。

### 4.5.1.  Packet Delivery Time

   数据包传递时间是接收方估计的将数据包传递给上游应用程序的时刻。数据包发送时间（PktTsbpdTime）的计算是在接收到一个数据包时按如下公式计算：

   PktTsbpdTime = TsbpdTimeBase + PKT_TIMESTAMP + TsbpdDelay + 漂移

   * TsbpdTimeBase 是反映接收方本地时钟与发送方使用的时钟之间的时间差的时基，用于对正在发送的数据包进行时间戳（参见第 4.5.1.1 节）；
   * PKT_TIMESTAMP 为数据包时间戳，单位为微秒；
   * TsbpdDelay 是接收器的缓冲延迟（或接收器的缓冲延迟，或 SRT 延迟）。这是 SRT 从收到数据包到应该将其交付给上游应用程序的时间（以毫秒为单位）；
   * 漂移是用于调整发送方和接收方时钟之间波动的时间漂移​​，以微秒为单位。

   SRT 延迟 (TsbpdDelay) 应该是一个足够大的缓冲时间，以覆盖意外延长的 RTT 时间，以及重新传输丢失数据包所需的时间。最小 TsbpdDelay 的值在 SRT 握手交换期间协商，等于 120 毫秒。TsbpdDelay 的推荐值为 RTT 的 3-4 倍。

   值得注意的是，TsbpdDelay 在一定程度上限制了数据包的重传次数，使得无法无休止地重传数据包。这对于实时数据传输很重要。

4.5.1.1.  TSBPD Time Base Calculation

   TSBPD 时基（TsbpdTimeBase）的初始值是在接收到第二次握手请求时计算的，如下所示：

   TsbpdTimeBase = T_NOW - HSREQ_TIMESTAMP

   其中 T_NOW 是根据接收器时钟的当前时间；HSREQ_TIMESTAMP 是握手包时间戳，以微秒为单位。

   TsbpdTimeBase 的值大约等于链路 RTT_0/2 的初始单向延迟，其中 RTT_0 是 SRT 握手交换期间往返时间的实际值。

   在传输过程中，TSBPD时基的值可能会在两种情况下进行调整：

   1. 在 TSBPD 打包期间。TSBPD 包装周期每 01:11:35 发生一次。该时间对应于数据包的最大时间戳值（MAX_TIMESTAMP）。MAX_TIMESTAMP 等于 0xFFFFFFFF，或 32 位无符号整数的最大值，以微秒为单位（第 3 节）。TSBPD 包装周期在达到数据包的最大时间戳值之前的 30 秒开始，并在时间戳在 (30, 60) 秒间隔内的数据包交付（从缓冲区读取）后结束。TsbpdTimeBase 的更新值将重新计算如下：

      TsbpdTimeBase = TsbpdTimeBase + MAX_TIMESTAMP + 1

   2. 通过漂移示踪剂。有关详细信息，请参阅第 4.7 节。

## 4.6.  Too-Late Packet Drop

   延迟丢包 (TLPKTDROP) 机制允许发送方丢弃没有机会及时传递的数据包，并允许接收方跳过未及时传递的丢失数据包。丢弃数据包的超时基于 TSBPD 机制（参见第 4.5 节）。

   在 SRT 中，如果启用了 Too-Late Packet Drop，并且数据包时间戳早于 SRT 延迟的 125%，则认为它发送得太晚，可能会被发送方丢弃。但是，发送方将数据包保留至少 1 秒，以防 SRT 延迟不足以用于大型 RTT（即，如果 125% 的 SRT 延迟小于 1 秒）。

   在接收器上启用后，接收器会丢弃未及时传递或重新传输的数据包，并在其播放时间时将后续数据包传递给应用程序。

   在伪代码中，从接收缓冲区读取的算法如下：
```
   <CODE BEGINS>
   pos = 0;  /* Current receiver buffer position */
   i = 0;    /* Position of the next available in the receiver buffer
                packet relatively to the current buffer position pos */

   while(True) {
       // Get the position i of the next available packet
       // in the receiver buffer
       i = next_avail();
       // Calculate packet delivery time PktTsbpdTime
       // for the next available packet
       PktTsbpdTime = delivery_time(i);

       if T_NOW < PktTsbpdTime:
           continue;

       Drop packets which buffer position number is less than i;

       Deliver packet with the buffer position i;

       pos = i + 1;
   }
   <CODE ENDS>
```
   其中 T_NOW 是根据接收器时钟的当前时间。

   可以关闭 TLPKTDROP 机制以始终确保干净的交付。但是，丢失的数据包可能会简单地暂停交付更长时间，可能未定义的时间，并导致玩家更严重的撕裂。在 TLPKTDROP 导致丢包太频繁的情况下，设置更高的 SRT 延迟会更有帮助。

## 4.7 漂移管理

   当发送方进入“Connected”状态时，它会告诉应用程序有一个已准备好发送器的套接字接口。此时应用程序可以开始发送数据包。它以一定的输入速率将数据包添加到 SRT 发送方的缓冲区，然后在预定的时间从那里将它们传输到接收方。

   考虑到时区和往返时间（卫星链路最长为 2 秒），需要同步时间来保持适当的发送方/接收方缓冲水平。考虑到加法/减法四舍五入以及可能不同步的系统时间，商定的时基每分钟漂移几微秒。漂移可能会在几天内累积到发送方或接收方缓冲区溢出或耗尽的程度，从而严重影响视频质量。SRT 有一个时间管理机制来补偿这种漂移。

   当接收到一个数据包时，SRT 确定它的预期时间和它的时间戳之间的差异。时间戳是在接收方计算的。RTT 告诉接收器它应该花费多少时间。SRT 维护发送缓冲区延迟窗口前沿的时间和接收器上的相应时间（当前时间）之间的参考。这允许将数据包时间戳转换为本地接收器时间。基于这个时间，可以安排各种事件（数据包传递等）。

   接收端对时间漂移数据进行采样，并周期性地计算出一个数据包时间戳校正因子，该校正因子通过调整包间间隔应用于接收到的每个数据包。当收到一个数据包时，它不会立即提供给应用程序。随着时间的推移，接收者知道任何丢失或丢弃的数据包的预期时间，并且可以使用此信息用另一个数据包填充接收队列中的任何“漏洞”（参见第 4.5 节）。

   值得注意的是，采样时间漂移数据的周期是基于数据包的数量而不是持续时间，以确保足够的样本，与媒体流的数据包速率无关。通过使用大量样本，网络抖动对估计时间漂移的影响被减弱。实际时间漂移非常慢（仅在数小时后影响流）不需要快速反应。

   接收器使用本地时间来安排事件——例如，确定是否该立即传送某个数据包。数据包本身中的时间戳只是对会话开始的引用。当接收到一个数据包（带有来自发送者的时间戳）时，接收者参考会话的开始以重新计算其时间戳。开始时间源自会话连接时的本地时间。数据包时间戳等于“now”减去“StartTime”，后者是创建套接字的时间点。


## 4.8 确认和丢包处理

   为了启用数据包重传的自动重复请求，发送方将所有发送的数据包存储在其缓冲区中。

   SRT 接收器定期发送接收到的数据包的确认（ACK），以便 SRT 发送器可以从其缓冲区中删除已确认的数据包（第 4.8.1 节）。一旦确认的数据包被删除，它们就不再可能并且可能不需要重新传输。

   在接收到完整确认 (ACK) 控制包后，SRT 发送方应通过发送带有已确认Full ACK 数据包序列号的 ACKACK 控制包来向接收方确认其接收。

   SRT 接收器还发送 NAK 控制包以通知发送器丢失的数据包（第 4.8.2 节）。在检测到数据包的序号有间隙后，可以立即触发NAK包的发送。此外，可以使用 Periodic NAK 报告机制来定期发送 NAK 报告。在这种情况下，NAK 数据包将列出在发送定期 NAK 报告之前，接收方认为丢失的所有数据包。

   在接收到 NAK 数据包后，SRT 发送器将丢失数据包的重传优先于第一次传输的常规数据包。

   丢失数据包的重传会重复，直到接收方确认收到，或者如果双方同意丢弃这个数据包（见第 4.6 节）。

### 4.8.1 数据包确认（ACKs、ACKACKs）

   在特定的时间间隔（见下文），SRT 接收器发送一个确认（ACK），导致确认的数据包从 SRT 发送器的缓冲区中删除。

   一个 ACK​​ 控制包包含紧跟接收数据包列表中最新的数据包的序列号。
   在序列号为 n 的数据包之前没有发生数据包丢失的情况下，ACK 将包括序列号 (n + 1)。

   ACK（来自接收方）将触发 ACKACK（由发送方）的传输，几乎没有延迟。发送 ACK 和接收 ACKACK 所花费的时间是 RTT。ACKACK 告诉接收方停止发送 ACK 位置，因为发送方已经知道它。否则，ACK（带有过时信息）将继续定期发送。同样，如果发送方没有收到 ACK，它也不会停止发送。

   发送确认有两个条件。Full ACK 基于 10 毫秒的计时器（ACK 周期或同步时间间隔 SYN）。对于高比特率传输，可以发送“Light ACK”，它是对数据包序列的 ACK。在 10 毫秒的时间间隔内，发送和接收的数据包通常非常多，以至于发送方的 ACK 位置前进得不够快。为了缓解这种情况，在 64 个数据包之后（即使 ACK 周期还没有完全过去），接收器发送一个Light ACK。Light ACK 是较短的 ACK（SRT 头和一个 32 位字段），它不会触发 ACKACK。

   当接收方遇到下一个要播放的数据包没有从发送方成功接收到的情况时，它会“跳过”这个数据包（参见第 4.6 节）并发送一个假的 ACK。对于发送者来说，这个假的 ACK 是一个真正的 ACK，所以它的行为就像数据包已经被接收一样。这有助于 SRT 发送方和接收方之间的同步。发送者仍然不知道数据包被跳过的事实。跳过的数据包记录在 SRT 接收器的统计信息中。

### 4.8.2 数据包重传 (NAK)

   SRT 接收器发送 NAK 控制包以通知发送器丢失的数据包。检测到数据包序号有间隙后，可以立即触发NAK包发送。

   在接收到 NAK 数据包后，SRT 发送器将丢失数据包的重传优先于第一次传输的常规数据包。

   SRT 发送方维护一个丢失数据包的列表（丢失列表），该列表是根据 NAK 报告构建的。在调度数据包传输时，它会查看丢失列表中的数据包是否具有优先级，如果有则发送。否则，它发送为第一个传输列表调度的下一个数据包。请注意，当数据包被发送时，它会留在缓冲区中，以防 SRT 接收器没有收到它。

   处理 NAK 数据包以填充丢失列表。随着延迟窗口的推进和数据包从发送队列中被丢弃，将执行检查以查看是否有任何丢弃或重新发送的数据包在丢失列表中，以确定它们是否也可以从那里删除，以免它们不在丢失列表中。不必要地重传。

   重新发送的数据包有一个计数器。如果一个数据包没有 ACK，它将留在丢失列表中，并且可以多次重发。丢失列表中的数据包优先。

   如果丢失列表中的数据包继续阻塞发送队列，在某些时候这将导致发送队列被填满。当发送队列已满时，发送者将开始丢弃数据包，甚至没有第一次发送它们。编码器（或其他应用程序）可能会继续提供数据包，但它们没有位置，因此它们最终会被丢弃。

   这种数据包未发送的情况并不经常发生。根据配置的延迟，发送缓冲区中保存的数据包数量有上限。没有机会重新传输和及时播放的旧数据包将被丢弃，从而为发送应用程序生成的新实时数据包腾出空间。有关详细信息，请参阅第 4.5 节、第 4.6 节。

   除了常规的 NAK 之外，还可以使用 Periodic NAK 报告机制定期发送 NAK 报告。在这种情况下，NAK 数据包将包含接收方在发送定期 NAK 报告时认为丢失的所有数据包。

   SRT 定期 NAK 报告的发送周期为 (RTT + 4 * RTTVar) / 2（所谓的 NAKInterval），下限为 20 毫秒，其中 RTT 和 RTTVar 在第 4.10 节中定义。NAK 控制包包含丢失数据包的压缩列表。因此，只重传丢失的数据包。通过将 NAKInterval 用于 NAK 报告周期，可能会发生多次重新传输丢失数据包的情况，但它有助于在 NAK 数据包丢失的情况下保持低延迟。

   ACKACK 告诉接收方停止发送 ACK 位置，因为发送方已经知道它。否则，ACK（带有过时信息）将继续定期发送。

   ACK 用作 ping，带有相应的 ACKACK pong，以测量 RTT。发送 ACK 和接收 ACKACK 所花费的时间是 RTT。每个 ACK​​ 都有一个编号。相应的 ACKACK 具有相同的编号。接收方在队列中保留所有 ACK 的列表以匹配它们。与包含当前 RTT 和控制信息字段 (CIF)（第 3.2.4 节）中的几个其他值的完整 ACK 不同，轻量级 ACK 仅包含序列号。所有控制消息都是直接发送并在接收时处理，但 ACKACK 处理时间可以忽略不计（此时间包含在往返时间中）。


## 4.9 双向传输队列

   一旦建立了 SRT 连接，双方就可以同时发送数据包。

## 4.10.  Round-Trip Time Estimation

   SRT 中的往返时间 (RTT) 是在数据包传输期间根据发送 ACK 包与 SRT 接收器接收回相应 ACKACK 包之间的时间差来估计的。

   接收方发送的 ACK 会以最小的处理延迟触发来自发送方的 ACKACK。ACKACK 响应预计会在相应的 ACK 发送后大约一个 RTT 到达接收器。

   SRT 接收器记录发送 ACK 的时间。ACK 携带唯一的序号（与数据包序号无关）。对应的ACKACK也携带相同的序列号。在收到 ACKACK 后，SRT 通过比较 ACKACK 到达时间和 ACK 离开时间之间的差异来计算 RTT。在以下公式中，RTT 是接收器维护的当前值，而 rtt 是刚刚从 ACK/ACKACK 对计算的最近值：

   RTT = RTT * 0.875 + rtt * 0.125

   RTT方差RTTVar得到如下：

   RTTVar = RTTVar * 0.75 + abs(RTT - rtt) * 0.25

   其中 abs() 表示绝对值。

   RTT 和 RTTVar 都以微秒为单位。RTT 的初始值为 100 毫秒，RTTVar 为 50 毫秒。

   接收方计算的平滑 RTT 以及 RTT 方差 RTTVar 与下一个Full Ack包一起发送（参见第 3.2.4 节）。请注意，SRT 会话中的第一个 ACK​​ 可能包含 100 毫秒的初始 RTT 值，因为早期计算可能不精确。

   发送者总是从接收者那里得到 RTT。它没有类似于 ACK/ACKACK 机制，即它不能发送保证立即返回而不进行处理的消息。在收到 ACK 后，SRT 发送方使用与上述相同的公式更新其自己的 RTT 和 RTTVar 值，在这种情况下，rtt 是它接收到的最新值，即由传入的 ACK 携带。

   请注意，SRT 套接字既可以发送也可以接收数据包。RTT 和 RTTVar 由套接字根据发送方（使用 ACK 数据包）和接收方（使用 ACK-ACKACK 对）的算法进行更新。当一个 SRT 套接字接收到数据时，它会更新它的本地 RTT 和 RTTVar，它们也可以用于它自己的发送方。

## 4.11 拥塞控制

   SRT 为发送方提供了一定的机制，可以通过 ACK 数据包从接收方获得一些反馈（第 3.2.4 节）。
   每 10 毫秒，发送方会收到 RTT 和 RTT 方差、可用缓冲区大小、数据包接收率和估计链路容量的最新值。在接收到 NAK 数据包（第 3.2.5 节）后，发送方可以检测到传输过程中的数据包丢失。这些机制为各种拥塞控制算法提供了坚实的背景。

   鉴于 SRT 可以在实时和文件传输模式下运行，因此有两组可能的拥塞控制算法。

   对于实时传输模式（第 4.2.2 节），拥塞控制算法不需要控制包的发送速度，因为发送时间由实时输入提供。尽管可以应用对连续数据包的最小互发时间的某些限制，以避免源比特率波动期间的拥塞。还允许丢弃那些不能及时传递的数据包。

   对于文件传输，任何已知的文件拥塞控制算法，如 CUBIC [RFC8312] 和 BBR [BBR] 都可以应用，包括 UDT [GHG04b]、[GuAnAO] 中提出的拥塞控制机制。UDT 拥塞控制依赖于可用的链路容量、数据包丢失报告 (NAK) 和数据包确认 (ACK)。然后，它通过调整数据包发送速度来根据需要减慢数据包的输出速度。在拥塞期间，它可以阻塞主流并专注于丢失的数据包。

# 5. 加密

   本节介绍保护 SRT 流有效负载的加密机制。基于标准密码算法，该机制允许使用密钥建立方法进行有效的流密码。

## 5.1 概述

   SRT 在计数器模式 (AES-CTR) [SP800-38A] 中使用 AES [AES] 实施加密，并使用短期密钥来加密和解密媒体流。AES-CTR 密码适用于允许从任何点解密的连续流加密，无需访问流的开始（随机访问），并且出于同样的原因可以容忍数据包丢失。如果柜台管理得当，它还可以提供很强的保密性。

### 5.1.1 加密范围

   SRT 仅加密 SRT 数据包的有效负载（第 3.1 节），而标头未加密。未加密的报头包含数据包序列号字段，用于保持加密发送方和解密接收方之间密码计数器的同步。对 SRT 数据包的有效载荷没有限制，因为计数器模式密码不需要填充有效载荷。

### 5.1.2 AES 计数器

   AES-CTR 的计数器是密码块的大小，即 128 位。它来自一个 128 位的序列，包括

   * 最低有效 16 位的块计数器，用于对数据包中的块进行计数，
   * 数据包索引 - 基于 SRT 标头中的数据包序列号 - 在接下来的 32 位中，
   * 八十个零位。

   该序列的高 112 位与初始化向量 (IV) 进行异或运算，以生成每个加密块的唯一计数器。IV 源自Key Material（第 3.2.2 节）中提供的Salt：

   IV = MSB(112, Salt)：Salt的最高有效 112 位。

### 5.1.3 流加密密钥 (SEK)

   用于 AES-CTR 加密的密钥称为“流加密密钥”（SEK）。它最多可用于 2^25 个数据包，并进行进一步的密钥更新。短期 SEK 由发送方使用伪随机数生成器 (PRNG) 生成，并在流中传输，并使用已知的 AES 密钥包装协议与另一个长期密钥 - 密钥加密密钥 (KEK) 一起包装.

   对于 SRT 等面向连接的传输，不需要定期传输短期密钥，因为没有其他方可以加入正在进行的流。Key Material在连接握手数据包中传输，并且在重新生成密钥时会在短时间内传输。

### 5.1.4 密钥加密密钥 (KEK)

   密钥加密密钥 (KEK) 源自发送者和接收者之间共享的秘密（密码）。KEK 提供对流加密密钥的访问，而流加密密钥又提供对受保护的 SRT 数据包有效负载的访问。KEK 必须至少与 SEK 一样长。

   KEK 由基于密码的密钥生成函数 (PBKDF2) [RFC2898] 生成，使用密码短语、多次迭代 (2048)、密钥哈希 (HMAC-SHA1) [RFC2104] 和密钥长度值 (克伦）。PBKDF2 函数通过重复或填充对密码短语进行哈希处理以形成一个长字符串。迭代次数取决于可以给流程多少时间而不会造成破坏。

### 5.1.5.  Key Material Exchange

   KEK 用于生成一个包装 [RFC3394]，该包装由连接的发起者（即呼叫者-侦听器握手中的调用者和会合握手中的发起者，参见第 4.3 节）放入Key Material (KM) 消息中以发送到响应者（听众）。KM 消息包含密钥长度、salt（提供给 PBKDF2 函数的参数之一）、正在使用的协议（例如 AES-256）和 AES 计数器（最终会改变，参见第 5.1.6 节）。

   另一方面，响应者尝试解码包装以获得流加密密钥。在 wrap 的协议中有一个填充，它是一个已知的模板，所以响应者从 KM 知道它有正确的 KEK 来解码 SEK。SEK（由发起者生成和传输）是随机的，无法提前知道。KEK公式是两边计算的，区别在于响应者通过Key Material（KM）从发起者那里得到密钥长度（KLen）。决定配置长度的是发起者。响应者从发起者发送的材料中获取。

   响应者返回相同的 KM 消息，表明它与发起者具有相同的信息，并且编码的材料将被解密。如果响应者没有返回这个状态，这意味着它没有 SEK。响应者收到的所有传入加密数据包都将丢失（未解密）。即使它们传输成功，接收者也无法解密它们，因此数据包将被丢弃。来自响应者的所有数据包都将不加密。

### 5.1.6.  KM Refresh

   当预定数量的数据包被加密时，由于加密原因，短期 SEK 会重新生成。KM 刷新周期由实现决定。接收方通过 SRT 数据包的 KK 字段（第 3.1 节）知道使用哪个 SEK（奇数或偶数）加密数据包。

   有两个变量用于确定 KM 刷新时间：
   * KM Refresh Period 指定在切换到新 SEK 之前要发送的数据包数，
   * KM Pre-Announcement Period 指定在密钥切换之前在多个数据包中宣布新密钥的时间。相同的值是
      用于确定切换后何时停用旧密钥。

   建议的 KM 刷新周期是在发送 2^25 个使用相同 SEK 加密的数据包之后。建议的 KM 预公告期为 4000 个数据包（即在 2^25 减去 4000 个数据包时生成、包装和发送新密钥；旧密钥在 2^25 加上 4000 个数据包时停用）。

   偶数和奇数密钥在传输过程中按以下方式交替。具有较早密钥#1（假设它是奇数密钥）的数据包将继续发送。接收方将收到新密钥#2（偶数），然后解密并解包。如果接收方能够理解，将回复发送方。一旦发送方使用奇数密钥（密钥#1）到达第 2^25 个数据包，它将开始使用偶数密钥（密钥#2）发送数据包，因为它知道接收方拥有解密它们所需的信息。这是透明地发生的，从一个数据包到下一个数据包。在 2^25 加上 4000 个数据包时，第一个密钥将自动停用。

   两个密钥在预先通知周期的两倍内并行存在（例如，密钥切换之前的 4000 个数据包，之后的 4000 个数据包）。这是为了允许数据包重传。具有较旧密钥的数据包可能会晚一点到达接收器。
   每个数据包都包含它需要哪个密钥的描述，因此接收者仍然可以解密它。


## 5.2 加密过程

### 5.2.1 生成流加密密钥

   在发送方 SEK、Salt 和 KEK 的生成方式如下：
```
   SEK  = PRNG(KLen)
   Salt = PRNG(128)
   KEK = PBKDF2(passphrase, LSB(64,Salt), Iter, Klen)
```
   where

   * PBKDF2 是 PKCS#5 基于密码的密钥派生函数 [RFC2898]，
   * 密码是预共享的密码，
   * Salt 是 KM 消息的字段，
   * LSB(n, v) 是取 v 的 n 个最低有效位的函数，
   * Iter=2048 定义了 PBKDF2 的迭代次数，
   * Klen 是 KM 消息的字段。
```
   Wrap = AESkw(KEK, SEK)
```
   其中 AESkw(KEK, SEK) 是密钥包装函数 [RFC3394]。

### 5.2.2 加密有效载荷

   SRT DATA 数据包有效载荷的加密是使用 AES-CTR 完成的
```
   EncryptedPayload = AES_CTR_Encrypt(SEK, IV, UnencryptedPayload)
```
   其中初始化向量派生为
```
   IV = (MSB(112, Salt) << 2) XOR (PktSeqNo)
```
   * PktSeqNo 是 SRT 数据包的 Packet Sequence Number 字段的值。

## 5.3 解密过程

### 5.3.1 恢复流加密密钥

   为了使接收方能够解密传入的流，它必须知道发送方使用的流加密密钥 (SEK)。接收方必须知道发送方使用的密码。剩余信息可以从Key Material消息中提取。

   Key Material消息包含编码器使用的 AES 包装的 [RFC3394] SEK。解包 SEK 所需的密钥加密密钥 (KEK) 计算如下：

   KEK = PBKDF2（密码，LSB（64，Salt），Iter，KLen）

   在哪里

   * PBKDF2 是 PKCS#5 基于密码的密钥派生函数 [RFC2898]，
   * 密码是预共享的密码，
   * Salt 是 KM 消息的字段，
   * LSB(n, v) 是取 v 的 n 个最低有效位的函数，
   * Iter=2048 定义了 PBKDF2 的迭代次数，
   * Klen 是 KM 消息的字段。

   SEK = AESkuw(KEK, Wrap)

   其中 AESkuw(KEK, Wrap) 是密钥解包函数。

### 5.3.2 解密有效载荷

   SRT数据包的payload解密是用AES-CTR完成的
```
   DecryptedPayload = AES_CTR_Encrypt(SEK, IV, EncryptedPayload)
```
   其中初始化向量派生为
```
   IV = (MSB(112, Salt) << 2) XOR (PktSeqNo)
```
   * PktSeqNo 是 SRT 数据包的 Packet Sequence Number 字段的值。



# 6. 安全注意事项

   SRT 使用基于 AES 的流加密支持用户数据的机密性。用于加密的会话密钥在握手期间通过控制包传递，并受到密钥加密密钥的保护，密钥加密密钥由发送者和接收者生成，具有预共享的秘密，例如密码。与 UDT 一样，谨慎使用 SYN Cookie 可能有助于阻止拒绝服务攻击。适当的安全策略，包括密钥大小、密钥刷新周期以及密码短语应由安全人员管理，这超出了本文档的范围。


# 7. IANA 注意事项

   本文档未向 IANA 提出任何要求。

# 贡献者

   该规范很大程度上基于 Jean Dube 和 Steve Matthews 编写的 SRT 协议技术概述 [SRTTO]。

   按照字母顺序，Haivision 的 pre-IETF SRT 项目和规范的贡献者是：Marc Cymontkowski、Roman Diouskine、Jean Dube、Mikolaj Malecki、Steve Matthews、Maria Sharabayko、Maxim Sharabayko、Adam Yellen。

   SK Telecom 的此规范的贡献者是 Jeongseok Kim 和 Joonwoong Kim。

   我们无法列出 GitHub 上 SRT 开源实现的所有贡献者。但我们感谢 SRT 和 SRT 联盟社区的帮助、贡献、整合和反馈。

# 致谢

   SRT 协议及其实现的基础是基于 UDP 的数据传输协议 [GHG04b]。作者感谢基于 UDP 的数据传输协议 [GHG04b] 的作者 Yunhong Gu 和 Robert Grossman。

   TODO 确认。

# 参考

## 参考规范

   [RFC0768] Postel, J.，“用户数据报协议”，STD 6，RFC 768，
              DOI 10.17487/RFC0768，1980 年 8 月，
              <https://www.rfc-editor.org/info/rfc768>。

   [RFC2119] Bradner, S.，“在 RFC 中使用的关键字来指示要求级别”，BCP 14，RFC 2119，
              DOI 10.17487/RFC2119，1997 年 3 月，
              <https://www.rfc-editor.org/info/rfc2119>。

## 参考资料

   [AES] 美国国家标准与技术研究院，“FIPS Pub 197：高级加密标准 (AES)”，2001 年 11 月，
              <http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf>。

   [AV1] Rivaz、Pd 和 J. Haughton，“AV1 比特流和解码工艺规范”，2020 年 9 月，
              <https://aomediacodec.github.io/av1-spec/av1-spec.pdf>。

   [BBR] Cardwell, N., Cheng, Y., Gunn, CS, Yeganeh, SH 和 V.
              Jacobson，“BBR：基于拥塞的拥塞控制”，
              2016 年 10 月。

   [GHG04b] Gu, Y.、Hong, X. 和 RL Grossman，“在高性能传输的设计与实现协议”，
              DOI 10.1109/SC.2004.24，2004 年 12 月，
              <https://doi.org/10.1109/SC.2004.24>。

   [GuAnAO] Gu, Y., Hong, X., and RL Grossman，“An Analysis of AIMD Algorithm with Dereducing increase”，2004 年 10 月。

   [H.265] 国际电信联盟，“H.265：高效视频编码”，ITU-T H.265 建议书，2019 年。

   [ID.ietf-quic-http]
              Bishop, M.，“超文本传输​​协议第 3 版(HTTP/3)”，正在进行的工作，Internet-Draft，
              draft-ietf-quic-http-29，2020 年 6 月 9 日，<http://www.ietf.org/internet-drafts/draft-ietf-quic-http-29.txt>。

   [ID.ietf-quic-transport]
              Iyengar, J. 和 M. Thomson，“QUIC：基于 UDP 的多路复用和安全传输”，正在进行的工作，互联网草案，
              Draft-ietf-quic-transport-29，2020 年 6 月 9 日，
              <http://www.ietf.org/internet-drafts/draft-ietf-quic-transport-29.txt>。

   [ISO13818-1]
              ISO，“信息技术——运动图像和相关音频信息的通用编码：系统”，ISO/IEC 13818-1，2020 年 9 月。

   [ISO23009] ISO，“信息技术——HTTP 上的动态自适应流式传输 (DASH)”，ISO/IEC 23009:2019，2020 年 9 月。

   [PNPID]“PNP ID 和 ACPI ID 注册表”，2020 年 9 月，
              <https://uefi.org/PNP_ACPI_Registry>。

   [RFC2104] Krawczyk, H.、Bellare, M. 和 R. Canetti，“HMAC：Keyed-
              用于消息身份验证的散列”，RFC 2104，
              DOI 10.17487/RFC2104，1997 年 2 月，
              <https://www.rfc-editor.org/info/rfc2104>。

   [RFC2898] Kaliski, B.，“PKCS #5：基于密码的密码学
              规范版本 2.0"，RFC 2898，
              DOI 10.17487/RFC2898，2000 年 9 月，
              <https://www.rfc-editor.org/info/rfc2898>。

   [RFC3031] Rosen, E.、Viswanathan, A. 和 R. Callon，“多协议
              标签交换架构”，RFC 3031，
              DOI 10.17487/RFC3031，2001 年 1 月，
              <https://www.rfc-editor.org/info/rfc3031>。

   [RFC3394] Schaad, J. 和 R. Housley，“高级加密标准
              (AES) 密钥包装算法”，RFC 3394，DOI 10.17487/RFC3394，
              2002 年 9 月，<https://www.rfc-editor.org/info/rfc3394>。

   [RFC4987] Eddy, W.，“TCP SYN 泛洪攻击和常见
              缓解”，RFC 4987，DOI 10.17487/RFC4987，2007 年 8 月，
              <https://www.rfc-editor.org/info/rfc4987>。

   [RFC8174] Leiba, B.，“RFC 2119 关键字中大写与小写的歧义”，BCP 14，RFC 8174，DOI 10.17487/RFC8174，
              2017 年 5 月，<https://www.rfc-editor.org/info/rfc8174>。

   [RFC8216] Pantos, R., Ed. 和 W. May，“HTTP Live Streaming”，
              RFC 8216，DOI 10.17487/RFC8216，2017 年 8 月，
              <https://www.rfc-editor.org/info/rfc8216>。

   [RFC8312] Rhee, I.、Xu, L.、Ha, S.、Zimmermann, A.、Eggert, L. 和 R. Scheffenegger，“用于快速长距离网络的 CUBIC”，
              RFC 8312，DOI 10.17487/RFC8312，2018 年 2 月，
              <https://www.rfc-editor.org/info/rfc8312>。

   [RTMP]“实时消息传递协议”，2020 年 9 月，<https://www.adobe.com/devnet/rtmp.html>。

   [SP800-38A] Dworkin, M.，“分组密码操作模式建议”，2001 年 12 月。

   [SRTSRC]《SRT全功能参考实现》，2020年9月，<https://github.com/Haivision/srt>。

   [SRTTO] Dube, J. 和 S. Matthews，“SRT 协议技术概述”，2019 年 12 月。

   [VP9] WebM，“VP9 视频编解码器”，2020 年 9 月，<https://www.webmproject.org/vp9>。

# 附录 A. 数据包序列表编码

   对于任何单个数据包序列号，它使用字段中的原始序列号。第一位必须以“0”开头。
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|                   Sequence Number                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                 Figure 18: Single sequence numbers coding
```
   对于任意连续的包序号，最后一个和第一个之差大于1，只在list字段中记录第一个（a）和最后一个（b）序号，并将a的第一位修改为“ 1"。
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|                   Sequence Number a (first)                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|                   Sequence Number b (last)                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                Figure 19: Range of sequence numbers coding
```


# 附录 B. SRT 访问控制

   在 SRT 中建立连接时可以交换的一种信息是流 ID，它可以用于调用者-侦听器连接布局。这是在调用方设置的最多 512 个字符的字符串。它可以在新接受的连接上的侦听器端检索。

   当 HS CONCLUSION到达时，SRT 侦听器可以通知上游应用程序有关连接尝试，从而公开 Stream ID 扩展消息的内容。基于此信息，应用程序可以接受或拒绝连接，选择所需的数据流，或为连接设置适当的密码。

   流 ID 值可用作自由格式，但有一个推荐的约定，以便所有 SRT 用户使用相同的语言。
   公约的目的是：
   * 促进自由格式名称之间的可读性和一致性，
   * 以 key-value 风格解释一些典型的数据。

## B.1 一般语法

   此推荐语法以 POSIX 中称为可执行规范的字符开头：#!。

   接下来的两个字符是：
```
   : - 这标志着 YAML 格式，目前唯一使用的内容格式，可以是：
       : - 没有嵌套的逗号分隔键
       { - 同上，但允许嵌套且必须以 } 结尾

   （嵌套意味着您可以在内部拥有多个级别的大括号​​封闭部件。）
```
   键值对的形式为：

   键1=值1，键2=值2...


## B.2 标准键

   除了一般语法之外，还有几个顶级键被视为标准键。所有单字母键定义，包括本节未列出的定义，均保留供将来使用。用户还可以使用带有 user_* 或 companyname_* 前缀的自定义键定义，其中 user 和 companyname 将替换为实际用户或公司名称。

   现有的键值不得扩展，并且不得与本节中描述的不同。

   以下键是标准的：

   * u：用户名或授权名，用于控制应使用哪个密码进行连接。应用程序应解释它以区分侦听方应使用哪个用户来设置密码。
   * r：资源名称标识资源的名称，如果侦听方能够服务多个资源，则便于选择。
   * h：主机名标识资源的主机名。例如，要使用 URI somehost.com/videos/queerry.php?vid=366 请求流，主机名字段应为 somehost.com，资源名称可以为 videos/query.php?vid=366 或简单的 366 . 请注意，这仍然是一个需要明确指定的键。应用简化和 URI 提取的支持工具预计仅在此处插入 URI 的主机部分。
   * s：Session ID是与服务器协商的临时资源标识符，仅用于验证。这是一次性标识符，第一次使用后失效。预期用途是首先通过单独的连接协商资源和授权的详细信息，然后在此处单独使用会话 ID。

   * t：类型指定连接的目的。定义了几种标准类型，但用户可以扩展使用：
      - 流（默认，如果未指定）：用于为应用程序定义的目的交换用户指定的有效负载，
      - 文件：用于传输文件，其中 r 是文件名，
      - auth：用于交换敏感数据。r 值说明了它的用途。到目前为止，还没有已知的具体可能值（未来使用）。

   * m：此连接的预期模式：
      - request（默认）：调用者想要接收流，
      - 发布：调用者想要发送流数据，
      - 双向：需要双向数据交换。

   注意，如果Stream ID不用于区分授权或资源，则不需要“m”，并且希望调用者发送数据。这仅适用于侦听器可以处理连接的各种目的的情况，因此需要知道调用者正在尝试做什么。

## B.3。例子

   StreamID 的示例内容为：
```
   #!::u=admin,r=bluesbrothers1_hi
```
   它指定要提供给调用者的流的用户名和资源名称。
```
   #!::u=johnny,t=file,m=publish,r=results.csv
```
   这指定该文件应从调用者传输到侦听器，其名称为 results.csv。

# 附录 C. 变更日志

## C.1。从版本 00

   * 改进和扩展“加密”部分的描述，
   * 改进和扩展“往返时间估计”部分的描述，
   * 将“握手”部分的描述扩展为“流 ID 扩展消息”、“组成员扩展”小节，
   * 扩展“握手消息”部分，详细说明握手过程，
   * 改进“关键材料”部分描述，
   * 更改了“数据包结构”部分的数据包结构格式，
   * 对“确认和丢失数据包处理”部分进行了少量补充，
   * 修复了断开的链接，
   * 扩展了参考列表。

# 作者地址

   马克西姆·沙拉贝科
   Haivision 网络视频有限公司

   电子邮件：maxsharabayko@haivision.com


   玛丽亚·沙拉贝科
   Haivision 网络视频有限公司

   电子邮件：msharabayko@haivision.com


   让·杜贝
   海威视

   邮箱：jdube@haivision.com


   金正锡
   SK电讯株式会社

   邮箱：jeongseok.kim@sk.com


   金俊雄
   SK电讯株式会社

   电子邮件：joonwoong.kim@sk.com

